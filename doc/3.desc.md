# Como funciona o limite de concorrência

O limite de concorrência aqui não olha “quantas req/s”, e sim **quantas requisições estão sendo processadas ao mesmo tempo.**

O mecanismo é um **semáforo** (um pool de vagas) implementado com chan struct{}.

Fluxo quando chega uma request:

* 1. O middleware de concorrência roda (antes do proxy)
     * ```concurrency.go```

* 2. Ele tenta **adquirir uma vaga** no pool
     * Chama ```ConcurrencyService.Acquire(r.Context())``` em ```concurrency_service.go```
     * Esse service aplica a regra de timeout:
          * ```CONCURRENCY_TIMEOUT``` <= 0: espera até conseguir vaga (ou até o request cancelar)
          * ```CONCURRENCY_TIMEOUT``` > 0: espera no máximo esse tempo; se estourar, falha

* 3. O pool real (infra) é um channel com buffer ```Max```
     * Criado por ```infra.NewChanPool(Max)``` em ```chanpool.go```
     * ```Acquire(ctx)``` faz um ```select```:
     * Se conseguir enviar no channel (```sem <- struct{}{}```) → pegou a vaga, retorna release() e ok=true
          * Se o ```ctx.Done()``` disparar (timeout/cancel) → ```ok=false```

* 4. Se não conseguiu vaga:
     * Middleware responde ```503 Service Unavailable``` (ou ```RejectStatus``` configurado)

* 5. Se conseguiu vaga:
     * Ele faz ```defer release()``` para liberar a vaga ao terminar
     * Chama o próximo handler (proxy → upstream)
     * Quando a request termina, ```release()``` tira um item do channel (```<-sem```), liberando espaço pra próxima.

Como pensar nele:```

* ```CONCURRENCY_MAX=3``` significa: “no máximo 3 requests simultâneas passam”.

* A 4ª request:
     * ou **espera** alguém terminar (se ```CONCURRENCY_TIMEOUT``` > 0 ou 0/infinito),
     * ou **falha** com 503 se não conseguir vaga a tempo.

Diferença prática vs rate limit (RPS):

* **Rate limit** controla “quantas por segundo” (token bucket).
* **Concorrência** controla “quantas ao mesmo tempo” (semáforo).

//// Se você quiser, eu te mostro um teste manual que evidencia isso: 
     fazer o upstream dormir 2s e disparar 10 requests em paralelo pra ver 503/espera 
     conforme CONCURRENCY_MAX e CONCURRENCY_TIMEOUT.