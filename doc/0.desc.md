# Estudando 00

O **store.go** é um “tipo de dados” (**uma struct**) com estado (mapa de limiters, config, mutex, TTL) e métodos (Get, Cleanup, StartJanitor, etc.).

Quando você cria `store := infra.NewStore(...)`, você está criando um “**componente**” que guarda e fornece **limiters por chave** (IP/api-key). Ele é a **infra** que o resto do sistema usa.

* **O middleware**
É o que “aplica” a funcionalidade no tráfego HTTP. Ele não decide o algoritmo do bucket em si; ele:
* pega a **chave** (IP/header),
* chama a **camada de aplicação** `(application.Service.Decide(...))`,
traduz a decisão para HTTP (`429` + headers) e/ou chama o próximo handler.
* **A camada de aplicação é quem centraliza a regra do “pode/não pode”**
Hoje a regra “se o limiter permitir, segue; senão bloqueia com Retry-After” fica em:
`service.go`

Então, de forma resumida:
* **infra** (`Store`) = “onde e como guardo/implemento os limiters”
* **application** (`Service`) = “regra de negócio: permitir ou bloquear (e Retry-After)”
* **adapter HTTP** (`middleware`) = “como extrair dados da request e responder 429/503”

## Diagrama de Fluxo do caminho da requisição no gateway

Fluxo (rate limit + concorrência + proxy)

```mermaid
flowchart TD
  A["Request chega no Gateway<br/>LISTEN_ADDR :8080"] --> B["RateLimit Middleware<br/>adapter HTTP"]

  B --> C["Calcula Key<br/>IP / RATE_KEY_HEADER / X-Forwarded-For"]
  C --> D["application.Service.Decide(key)"]
  D --> E["infra.Store.Get(key)"]
  E --> F["Limiter por key<br/>(token bucket)"]
  F --> G["limiter.Allow()?"]

  G -->|não| H["Decision: Allowed=false<br/>RetryAfter"]
  H --> I["HTTP 429 Too Many Requests<br/>Retry-After"]

  G -->|sim| J["Decision: Allowed=true"]
  J --> K["Concurrency Middleware"]
  K --> L["application.ConcurrencyService.Acquire(ctx)"]
  L --> M["infra.ChanPool.Acquire(ctx)"]
  M --> N["Conseguiu vaga?"]

  N -->|não| O["HTTP 503 Service Unavailable"]
  N -->|sim| P["defer release()"]
  P --> Q["Reverse Proxy"]
  Q --> R["Encaminha para UPSTREAM_URL"]
  R --> S["Response do upstream volta"]
  S --> T["Response final ao cliente"]
```

