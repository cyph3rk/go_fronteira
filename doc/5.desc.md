
# Limpeza


* ```StartJanitor()``` é só o “agendador” que chama ```Cleanup()``` periodicamente.

 * ```Cleanup()``` (em ```store.go:77```) implementa a limpeza em si: calcula um ```cutoff = now - idleTTL``` e remove do map todas as keys cujo ```lastSeen``` está antes desse ```cutoff``` (ou seja, ficaram “ociosas” mais que ```idleTTL```).
 * ```StartJanitor(ctx)``` (em ```store.go:92```) cria um ```time.Ticker``` com ```cleanupEvery``` e sobe uma goroutine que faz um loop:
se ```ctx.Done()``` fechar → para a goroutine (e o ticker é parado via ```defer t.Stop()```)
 * se chegar um tick ```(<-t.C)``` → chama ```s.Cleanup()```

Como ler os dois tempos juntos:

* ```idleTTL``` define “o que é velho o suficiente para apagar” (default 15 min em ```store.go:43```).
* ```cleanupEvery``` define “de quanto em quanto tempo eu vou checar e apagar” (default 2 min em ```store.go:44```.

**Detalhe importante**: Se ```cleanupEvery <= 0```, ```StartJanitor()``` não inicia nada (retorna cedo) em ```store.go:93```.





O ```Cleanup()```  faz uma “varredura” no cache de limiters e remove as chaves que ficaram tempo demais sem uso.

Como funciona (em ```store.go```):

* Cada key (ex.: IP ou api-key) vira uma entrada em ```s.entries[key]``` com:
    * lim: o token-bucket (*rate.Limiter)
    * lastSeen: quando aquela key foi usada pela última vez
* Toda vez que chega request para uma key, ```GetString()``` atualiza ```ent.lastSeen = now``` antes de devolver o limiter.

No ```Cleanup()```:

* Ele calcula um “corte” (```cutoff```) assim: ```time.Now().Add(-s.idleTTL)``` 
- Ou seja: “qualquer coisa que não é vista há mais de ```idleTTL``` é considerada inativa”.
Depois, com o mutex travado, ele percorre o map e faz ```delete(s.entries, k)``` para toda entrada cujo ```lastSeen.Before(cutoff)```.

Efeito prático:

* Evita que o map cresça pra sempre quando aparecem muitas keys “únicas” (ex.: muitos IPs diferentes).
* Faz com que, se uma key ficar inativa por mais de ```idleTTL``` (default 15 min), o limiter dela seja descartado; na próxima request dessa key, um limiter novo é criado (com o bucket “zerado/novo”, conforme ```rate.NewLimiter```).

Se você quiser, eu também te explico a relação com StartJanitor() (o ticker que chama Cleanup() a cada ```cleanupEvery```).

